# -*- coding: utf-8 -*-
"""House_Predict.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11pgVg4W9Yn1tTAkyTPnQK9jdaEXs7L2-
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from pandas.plotting import scatter_matrix

df = pd.read_csv('/content/drive/MyDrive/Colab_Notebooks/raw_house_data.csv')
df

# Remove unnecassary comluns
not_needed = ['MLS','floor_covering', 'kitchen_features', 'fireplaces']
df = df.drop(not_needed, axis=1)
df

# Rename the columns
df.columns = ['Price_of_House', 'Zip_Code', 'Longitude', 'Latitude', 'Lot_Size','Taxes', 'Year_Built', 'Bedrooms', 'Bathrooms', 'Square_Footage', 'Garage', 'HOA']

df.info()

df.describe()

df.hist(bins=50, figsize=(20,15))
plt.show()

# Check the types of the columns
df.dtypes

# Look for the null values
df.isnull().sum()

# Check for all the None values in the columns

missing_values = {}
for missing in df.columns:
  none_values = df[df[missing] == 'None'].shape
  missing_values[missing]= none_values[0]
missing_values

"""## Deal with missing values and None values"""

'''
Check how many none values
Check if values can be removed
Check the type of the column to see if it is correct
Check what the appropriate value is to replace with the None
'''
df[df['HOA'] == 'None'].shape
df[df.values == 'None']

attributes = ['Price_of_House', 'Bathrooms', 'Zip_Code', 'Lot_Size']
scatter_matrix(df[attributes], figsize=(20, 15))

# Check the statistics of the columns

df['HOA'] = df.HOA.str.replace(',', '')
df[df['HOA'] != 'None']['HOA'].astype(float).describe()

df[df['Garage'] != 'None']['Garage'].astype(float).describe()

df[df['Square_Footage'] != 'None']['Square_Footage'].astype(float).describe()

df[df['Bathrooms'] != 'None']['Bathrooms'].astype(float).describe()

# Replace the None value with an appropriate value

df['HOA'] = np.where((df['Price_of_House'] <= 250000) & (df['HOA'] == 'None'), 56, df['HOA'])
df['HOA'] = np.where((df['Price_of_House'] >= 250000) & (df['Price_of_House'] <= 400000) & (df['HOA'] == 'None'), 135, df['HOA'])
df['HOA'] = np.where((df['Price_of_House'] >= 400000) & (df['HOA'] == 'None'), 200, df['HOA'])
df['HOA'] = df['HOA'].astype(float)
df['Garage'] = df.Garage.replace('None', str(int(2.816143)))
df['Garage'] = df['Garage'].astype(float)
df['Bathrooms'] = df.Bathrooms.replace('None', str(int(3.829896)))
df['Bathrooms'] = df['Bathrooms'].astype(float)
df['Square_Footage'] = df.Square_Footage.replace('None', str(3512))
df['Square_Footage'] = df['Square_Footage'].astype(float)

# Check for zero values that do not belong

zero_values = {}
for zero_val in df.columns:
  l = df[df[zero_val] == 0].shape
  zero_values[zero_val] = l[0]
zero_values

df['Year_Built'].describe()

df.Year_Built.plot.hist()

# Fix the zero values
df['Year_Built'] = df.Year_Built.replace(0, 1999)

df['Lot_Size'].describe()

df['Lot_Size'] = df['Lot_Size'].fillna(1)

df.Lot_Size.plot.hist()

df['Lot_Size'] = df.Lot_Size.replace(0, 1)

# Make sure all missing values are filled
missing_values = {}
for missing in df.columns:
  none_values = df[df[missing] == 'None'].shape
  missing_values[missing]= none_values[0]
missing_values

"""## Outliers"""

sns.distplot(df['Price_of_House'])

sns.boxplot(x=df['Price_of_House'])

df = df.drop(df[df['Price_of_House'].values >= 1100000].index)
df = df.drop(df[df['Price_of_House'].values <= 400000].index)
sns.boxplot(x=df['Price_of_House'])

sns.boxplot(x=df['Zip_Code'])

df = df.drop(df[df['Zip_Code'].values < 85600].index)
df = df.drop(df[df['Zip_Code'].values > 85800].index)
sns.boxplot(x=df['Zip_Code'])

sns.boxplot(x=df['Longitude'])

sns.boxplot(x=df['Latitude'])

sns.boxplot(x=df['Lot_Size'])

df = df.drop(df[df['Lot_Size'].values > 2].index)
df = df.drop(df[df['Lot_Size'].values <= 0].index)
sns.boxplot(x=df['Lot_Size'])

sns.boxplot(x=df['Year_Built'])

df = df.drop(df[df['Year_Built'] < 1900].index)
sns.boxplot(x=df['Year_Built'])

sns.boxplot(x=df['Bedrooms'])

df = df.drop(df[df['Bedrooms'] > 10].index)
sns.boxplot(x=df['Bedrooms'])

sns.boxplot(x=df['Bathrooms'])

df = df.drop(df[df['Bathrooms'] > 10].index)
sns.boxplot(x=df['Bathrooms'])

sns.boxplot(x=df['Square_Footage'])

df  = df.drop(df[df['Square_Footage'] > 5000].index)
sns.boxplot(x=df['Square_Footage'])

sns.boxplot(x=df['Garage'])

df = df.drop(df[df['Garage'] > 10].index)
sns.boxplot(x=df['Garage'])

sns.boxplot(x=df['HOA'])

df = df.drop(df[df['HOA'] > 400].index)
sns.boxplot(x=df['HOA'])

df.hist(bins=50, figsize=(20,15))
plt.show()

"""## Important Features

"""

df.dtypes

df.Price_of_House.plot.hist()

plt.figure(figsize=(20,7))
plt.scatter(df['Zip_Code'], df['Price_of_House'])

plt.xlabel('Zip Code', size=8)
plt.ylabel('Price of House', size=8)

plt.figure(figsize=(20,10))
plt.scatter(df['Longitude'], df['Price_of_House'])
plt.xlabel('Longitude', size=8)
plt.ylabel('Price of House', size=8)

plt.figure(figsize=(20,10))
plt.scatter(df['Latitude'], df['Price_of_House'])
plt.xlabel('Latitude', size=8)
plt.ylabel('Price of House', size=8)

plt.figure(figsize=(20,10))
var = 'Lot_Size'
data = pd.concat([df['Price_of_House'], df[var]], axis=1)
data.plot.scatter(x=var,y='Price_of_House')

plt.figure(figsize=(20,10))
plt.scatter(df['Lot_Size'], df['Price_of_House'], alpha=0.1)
plt.xlabel('Lot_Size', size=8)
plt.ylabel('Price of House', size=8)

plt.figure(figsize=(20,10))
plt.scatter(df['Year_Built'], df['Price_of_House'], alpha=0.2)
plt.xlabel('Year_Built', size=8)
plt.ylabel('Price of House', size=8)

plt.figure(figsize=(20,10))
plt.scatter(df['Bedrooms'], df['Price_of_House'])
plt.xlabel('Bedrooms', size=8)
plt.ylabel('Price of House', size=8)

plt.figure(figsize=(20,10))
plt.scatter(df['Bathrooms'], df['Price_of_House'])
plt.xlabel('Bathrooms', size=8)
plt.ylabel('Price of House', size=8)

plt.figure(figsize=(20,10))
plt.scatter(df['Garage'], df['Price_of_House'])
plt.xlabel('Garage', size=8)
plt.ylabel('Price of House', size=8)

plt.figure(figsize=(20,10))
plt.scatter(df['HOA'], df['Price_of_House'])
plt.xlabel('HOA', fontsize=8)
plt.ylabel('Price of House', fontsize=8)

corr_matrix = df.corr()
sns.heatmap(corr_matrix)

"""## Add the new feature 'Pools'

"""

from numpy.core.fromnumeric import size
plt.figure(figsize=(20,8))
plt.scatter(df['Longitude'], df['Latitude'])
plt.xlabel('Longitude', size=15)
plt.ylabel('Latitude', size=15)

fig = px.scatter_mapbox(df[(df['Longitude'] < -110.6) & (df['Longitude'] > -111.2)], 
                        lat = 'Latitude', lon = 'Longitude', color = 'Price_of_House',
                        center=dict(lon=-111, lat=32.37),
                       zoom = 10, mapbox_style = 'open-street-map')
fig

df['Pool'] = 0
df['Pool'] = np.where((df['Price_of_House'] > 150000) & (df['HOA'] > 100) & (df['Lot_Size'] > 1/4), 1, df['Pool'])
df[df['Pool'] == 1].shape

fig = px.scatter_mapbox(df[(df['Longitude'] < -110.6) & (df['Longitude'] > -111.2)], 
                        lat = 'Latitude', lon = 'Longitude', color = 'Pool',
                        center=dict(lon=-111, lat=32.37),
                       zoom = 10, mapbox_style = 'open-street-map')
fig

df

# train = df.sample(frac=.85)
# test = df.drop(train.index)
# validate = train.sample(frac=.1175)
# train = train.drop(validate.index)
# train.shape, test.shape, validate.shape

from zlib import crc32

def test_set_check(identifier, test_ratio):
  return crc32(np.int64(identifier)) & 0xffffffff < test_ratio * 2**32

def split_train_test_by_id(data, test_ratio, id_column):
  ids = data[id_column]
  in_test_set = ids.apply(lambda id_: test_set_check(id_, test_ratio))
  return data.loc[~in_test_set], data.loc[in_test_set]

df_with_id = df.reset_index()
train, test = split_train_test_by_id(df_with_id, 0.15, 'index')
validate = train.sample(frac=.1175)
train = train.drop(validate.index)
train.shape,test.shape, validate.shape

train = train.drop(['index'], axis=1)
validate = validate.drop(['index'], axis=1)
test = test.drop(['index'], axis=1)

train.shape,validate.shape,test.shape

class MultipleLinearRegression():
  
  def fit(self, X, y):
    self.W = np.linalg.solve(X.T@X, X.T@y)
  
  def predict(self, X):

    return np.matmul(X, self.W)

def OLS(Y, Y_hat, N):
  return(1/(2*N)*np.sum(Y-Y_hat)**2)

class OurLinearRegression():

  def fit(self, X, y, eta = 1e-3, epochs= 1e3, show_curve= False): #eta is the learning rate
    epochs = int(epochs)
    N,D = X.shape
    Y = y

    # Stochastic initialization of weights
    self.W = np.random.randn(D)

    J = np.zeros(epochs)

    for epoch in range(epochs):
      Y_hat = self.predict(X)
      J[epoch] = OLS(Y, Y_hat, N)            # Error Calculation
      self.W -= eta*(1/N)*(X.T@(Y_hat-Y))    # weights update rule

    if show_curve:
      plt.figure()
      plt.plot(J)
      plt.xlabel('epochs')
      plt.ylabel('$\mathcal{J}$')
      plt.title('Training Curve')
      plt.show()
  
  def predict(self, X):
    return X@self.W

# trainning = MultipleLinearRegression()
# #trainning = OurLinearRegression()

X_train = train.to_numpy()
y_train = X_train[:,-1]
X_train = X_train[:,:-1]

# Normalize the test values

X_train = (X_train - X_train.min())/(X_train.max() - X_train.min())
#X_train = (X_train - X_train.mean())/X_train.std()

X1 = ['HOA', 'Price_of_House']
X2 = ['Longitude', 'Latitude', 'Price_of_House']
X3 = ['Lot_Size'] + X1
X4 = ['Zip_Code', 'Price_of_House']
X5 = ['Bedrooms', 'Bathrooms']
X6 = ['Square_Footage'] + X1
X7 = ['Price_of_House', 'Zip_Code', 'Longitude', 'Latitude','Lot_Size', 'Taxes', 'Year_Built',\
      'Bathrooms', 'Bedrooms', 'Square_Footage', 'Garage', 'HOA']
Xt = np.empty((7, 0)).tolist()

Xt[0] = X1
Xt[1] = X2
Xt[2] = X3
Xt[3] = X4
Xt[4] = X5
Xt[5] = X6
Xt[6] = X7
Xt

for x in Xt:
  trainning = MultipleLinearRegression()
  trainning.fit(train[x], y_train)
  y_hat_train = trainning.predict(train[x])
  print(train[x].shape, (np.linalg.solve(train[x].T@train[x], train[x].T@y_train)).shape)

def R2(Y, Y_hat):
  return (1-(np.sum((Y-Y_hat)**2)/np.sum((Y-np.mean(Y))**2)))

X_validate = validate.to_numpy()
y_validate = X_validate[:,-1]
X_validate = X_validate[:,:-1]

X_validate = (X_validate - X_validate.min())/(X_validate.max() - X_validate.min())

Xt2 = Xt.copy()
for x1 in Xt2:
  # y_hat_validate = trainning.predict(validate[x1])
  print(np.matmul(validate[x1], (np.linalg.solve(validate[x1].T@validate[x1], validate[x1].T@y_validate))))

# X_validate = validate[['Pool', 'Price_of_House', 'Square_Footage']]
# X_validate = X_validate.to_numpy()
# y_validate = X_validate[:,0]
# X_validate = X_validate[:, 1:]

# X_validate = (X_validate - X_validate.min())/(X_validate.max() - X_validate.min())
# #X_validate = (X_validate - X_validate.mean())/X_validate.std()
# X_validate.shape

#y_hat_validate = trainning.predict(X_validate)

#R2(y_validate, y_hat_validate)

X_test = test[['Pool', 'Price_of_House',  'Square_Footage']]
X_test = X_test.to_numpy()
y_test = X_test[:,-1]
X_test = X_test[:,:-1]
# Normalize the test values

X_test = (X_test - X_test.min())/(X_test.max() - X_test.min())
#X_test = (X_test - X_test.mean())/X_test.std()
y_test.shape, test.shape,X_test.shape

# y_hat_test = trainning.predict(X_test)

# R2(y_test, y_hat_test)

for x in Xt:
  # y_hat_test = trainning.predict(test[x])
  print(test[x].shape,(np.linalg.solve(test[x].T@test[x], test[x].T@y_test)).shape)

